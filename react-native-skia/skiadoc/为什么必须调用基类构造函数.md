# 为什么必须调用基类构造函数？

## 📋 问题

```cpp
class HarmonyPlatformContext : public RNSkPlatformContext {
    // ...
};

HarmonyPlatformContext::HarmonyPlatformContext(...)
    : RNSkPlatformContext(runtime, callInvoker, pixelDensity),  // ← 为什么要调用？
      drawLoopActive(false)
{
}
```

为什么要调用基类构造函数？

## 🎯 核心答案

**因为子类对象包含父类的所有成员，必须先初始化父类部分，才能初始化子类部分。**

---

## 1. C++ 继承的本质

### 1.1 继承关系

```cpp
class RNSkPlatformContext {          // 基类（父类）
    // 父类的成员变量和方法
};

class HarmonyPlatformContext : public RNSkPlatformContext {  // 派生类（子类）
    // 子类的成员变量和方法
};
```

### 1.2 子类对象的内存布局

**关键理解：子类对象 = 父类部分 + 子类部分**

```
HarmonyPlatformContext 对象（完整对象）
├─ 父类部分（RNSkPlatformContext）
│  ├─ _pixelDensity (float)
│  ├─ _jsRuntime (jsi::Runtime*)
│  ├─ _callInvoker (std::shared_ptr<react::CallInvoker>)
│  ├─ _dispatchQueue (std::unique_ptr<RNSkDispatchQueue>)
│  └─ _jsThreadId (std::thread::id)
│
└─ 子类部分（HarmonyPlatformContext）
   ├─ drawLoopActive (bool)
   ├─ playLink (std::unique_ptr<PlayLink>)
   ├─ taskQueue (std::queue<...>)
   └─ ...
```

**重要：**
- 子类对象**包含**父类的所有成员
- 父类部分和子类部分在内存中是**连续存储**的
- 父类部分在**前面**，子类部分在**后面**

---

## 2. 为什么必须初始化父类部分？

### 2.1 初始化顺序的必要性

**C++ 规则：必须先初始化父类，再初始化子类**

```
创建 HarmonyPlatformContext 对象
    ↓
1. 必须先初始化父类部分（RNSkPlatformContext）
   └─ 调用 RNSkPlatformContext 构造函数
       └─ 初始化父类的所有成员变量
    ↓
2. 再初始化子类部分（HarmonyPlatformContext）
   └─ 初始化子类的所有成员变量
```

**为什么？**

1. **内存布局要求**
   - 父类部分在内存中先分配
   - 必须先初始化父类部分，才能知道子类部分从哪里开始

2. **依赖关系**
   - 子类可能依赖父类的成员
   - 如果父类没初始化，子类无法安全使用父类成员

3. **对象完整性**
   - 对象必须是一个完整的、有效的对象
   - 父类部分未初始化，对象就不完整

### 2.2 类比理解

**想象建房子：**

```
建房子（创建对象）
    ↓
1. 先打地基（初始化父类）
   └─ 必须先把地基打好
    ↓
2. 再建房子（初始化子类）
   └─ 在地基上建房子
```

**如果先建房子再打地基？**
- ❌ 房子会倒塌（对象无效）
- ❌ 不安全（未定义行为）

---

## 3. 如果不调用基类构造函数会怎样？

### 3.1 情况 1：基类有默认构造函数

```cpp
class RNSkPlatformContext {
public:
    RNSkPlatformContext() {  // 默认构造函数
        // 默认初始化
    }
    RNSkPlatformContext(jsi::Runtime *runtime, ...) {  // 带参数的构造函数
        // 用参数初始化
    }
};

// 子类不显式调用基类构造函数
HarmonyPlatformContext::HarmonyPlatformContext(...)
    : drawLoopActive(false)  // 不调用基类构造函数
{
}
```

**结果：**
- ✅ 编译通过
- ⚠️ 编译器会自动调用基类的**默认构造函数** `RNSkPlatformContext()`
- ⚠️ 父类成员可能使用默认值，而不是传入的参数值

**问题：**
- 父类成员可能没有正确初始化
- 例如：`_jsRuntime` 可能是 `nullptr`，而不是传入的 `runtime`

### 3.2 情况 2：基类没有默认构造函数（当前情况）

```cpp
class RNSkPlatformContext {
public:
    // 只有带参数的构造函数，没有默认构造函数
    RNSkPlatformContext(jsi::Runtime *runtime, ...) {
        // ...
    }
};

// 子类不显式调用基类构造函数
HarmonyPlatformContext::HarmonyPlatformContext(...)
    : drawLoopActive(false)  // 不调用基类构造函数
{
}
```

**结果：**
- ❌ **编译错误！**
- 编译器不知道如何初始化父类部分
- 因为基类没有默认构造函数

**错误信息示例：**
```
error: no matching function for call to 'RNSkPlatformContext::RNSkPlatformContext()'
note: candidate constructor not viable: requires 3 arguments, but 0 were provided
```

### 3.3 当前代码的情况

**基类定义：**
```cpp
// RNSkPlatformContext.h:40
class RNSkPlatformContext {
public:
    RNSkPlatformContext(jsi::Runtime *runtime,
                       std::shared_ptr<react::CallInvoker> callInvoker,
                       float pixelDensity)  // ← 只有带参数的构造函数
        : _pixelDensity(pixelDensity), 
          _jsRuntime(runtime),
          _callInvoker(callInvoker),
          // ...
    {
    }
    // 没有默认构造函数 RNSkPlatformContext()
};
```

**结论：**
- 基类**没有默认构造函数**
- **必须**在子类构造函数中显式调用基类构造函数
- 否则编译失败

---

## 4. 如何调用基类构造函数？

### 4.1 在初始化列表中调用

```cpp
HarmonyPlatformContext::HarmonyPlatformContext(...)
    : RNSkPlatformContext(runtime, callInvoker, pixelDensity),  // ← 调用基类构造函数
      drawLoopActive(false)
{
}
```

**语法：**
- 在初始化列表的最前面
- 格式：`基类名(参数列表)`
- 用逗号 `,` 分隔后续的初始化项

### 4.2 参数传递

```cpp
HarmonyPlatformContext::HarmonyPlatformContext(
    jsi::Runtime *runtime,                    // ← 参数 #1
    std::shared_ptr<react::CallInvoker> callInvoker,  // ← 参数 #2
    float pixelDensity)                      // ← 参数 #3
    : RNSkPlatformContext(runtime, callInvoker, pixelDensity)
    //                    ↑        ↑           ↑
    //                    将构造函数的参数传递给基类构造函数
```

**流程：**
```
子类构造函数接收参数
    ↓
传递给基类构造函数
    ↓
基类构造函数初始化父类成员
    ↓
子类构造函数继续初始化子类成员
```

---

## 5. 初始化顺序详解

### 5.1 完整的初始化顺序

```
创建 HarmonyPlatformContext 对象
    ↓
1. 分配内存（为整个对象分配内存）
    ↓
2. 调用子类构造函数
    ↓
3. 执行初始化列表
    ↓
   3.1 先调用基类构造函数
       RNSkPlatformContext(runtime, callInvoker, pixelDensity)
       └─ 初始化父类成员：
          - _pixelDensity = pixelDensity
          - _jsRuntime = runtime
          - _callInvoker = callInvoker
          - _dispatchQueue = std::make_unique<RNSkDispatchQueue>(...)
          - _jsThreadId = std::this_thread::get_id()
    ↓
   3.2 再初始化子类成员变量
       drawLoopActive = false
       playLink = std::make_unique<PlayLink>(...)
       taskQueue = std::queue<>()
       // ...
    ↓
4. 执行构造函数体
   mainThread = std::thread(...)
   _runtime = runtime
```

### 5.2 为什么基类构造函数必须在最前面？

**C++ 规则：**
- 基类构造函数必须在初始化列表的**最前面**
- 不能在其他初始化项之后

**正确：**
```cpp
: RNSkPlatformContext(...),  // ← 基类构造函数在最前面
  drawLoopActive(false)      // ← 成员变量在后面
```

**错误：**
```cpp
: drawLoopActive(false),     // ← 错误！成员变量不能在基类构造函数前面
  RNSkPlatformContext(...)    // ← 基类构造函数必须在最前面
```

**原因：**
- 初始化顺序是固定的：先父类，后子类
- 编译器会检查并强制这个顺序

---

## 6. 实际例子

### 6.1 如果不调用基类构造函数

```cpp
// 假设可以这样写（实际上会编译错误）
HarmonyPlatformContext::HarmonyPlatformContext(...)
    : drawLoopActive(false)  // 不调用基类构造函数
{
    // 问题：
    // 1. 父类成员 _jsRuntime 未初始化（可能是 nullptr）
    // 2. 父类成员 _callInvoker 未初始化（可能是 nullptr）
    // 3. 父类成员 _pixelDensity 未初始化（可能是 0.0）
    // 4. 如果子类代码使用这些成员，会导致崩溃或未定义行为
}
```

**问题场景：**
```cpp
// 在子类方法中使用父类成员
void HarmonyPlatformContext::someMethod() {
    _jsRuntime->...  // ❌ 如果 _jsRuntime 是 nullptr，会崩溃！
    _callInvoker->...  // ❌ 如果 _callInvoker 是 nullptr，会崩溃！
}
```

### 6.2 正确调用基类构造函数

```cpp
HarmonyPlatformContext::HarmonyPlatformContext(...)
    : RNSkPlatformContext(runtime, callInvoker, pixelDensity),  // ✅ 正确初始化父类
      drawLoopActive(false)
{
    // 现在可以安全使用父类成员：
    // - _jsRuntime 已正确初始化为 runtime
    // - _callInvoker 已正确初始化为 callInvoker
    // - _pixelDensity 已正确初始化为 pixelDensity
}
```

---

## 7. 多继承的情况

### 7.1 多个基类

```cpp
class Base1 { ... };
class Base2 { ... };

class Derived : public Base1, public Base2 {
public:
    Derived(...)
        : Base1(...),    // ← 先初始化 Base1
          Base2(...),    // ← 再初始化 Base2
          member(0)      // ← 最后初始化成员变量
    {
    }
};
```

**规则：**
- 按继承顺序初始化基类
- 所有基类构造函数必须在成员变量之前

---

## 8. 总结

### 8.1 为什么必须调用基类构造函数？

1. **对象完整性**
   - 子类对象包含父类部分
   - 必须先初始化父类部分，对象才完整

2. **内存布局**
   - 父类部分在内存中先分配
   - 必须先初始化父类，才能初始化子类

3. **依赖关系**
   - 子类可能依赖父类成员
   - 父类未初始化，子类无法安全使用

4. **C++ 语言规则**
   - 如果基类没有默认构造函数，必须显式调用
   - 基类构造函数必须在初始化列表最前面

### 8.2 关键点

- ✅ **子类对象 = 父类部分 + 子类部分**
- ✅ **必须先初始化父类，再初始化子类**
- ✅ **基类构造函数必须在初始化列表最前面**
- ✅ **如果基类没有默认构造函数，必须显式调用**

### 8.3 类比记忆

**建房子：**
- 先打地基（初始化父类）
- 再建房子（初始化子类）

**不能先建房子再打地基！**

---

**文档版本**: 1.0  
**最后更新**: 2025-01-XX  
**维护者**: AI Assistant
